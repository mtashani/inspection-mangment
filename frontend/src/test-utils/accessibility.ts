/**\n * Accessibility Testing Utilities\n * Provides utilities for testing WCAG compliance and accessibility features\n */\n\nimport { render, RenderOptions } from '@testing-library/react'\nimport { axe, toHaveNoViolations } from 'jest-axe'\nimport React, { ReactElement } from 'react'\n\n// Extend Jest matchers\nexpect.extend(toHaveNoViolations)\n\n/**\n * Color contrast utilities\n */\nexport const colorContrast = {\n  /**\n   * Calculate relative luminance of a color\n   */\n  getLuminance(hex: string): number {\n    // Remove # if present\n    hex = hex.replace('#', '')\n    \n    // Convert to RGB\n    const r = parseInt(hex.substr(0, 2), 16) / 255\n    const g = parseInt(hex.substr(2, 2), 16) / 255\n    const b = parseInt(hex.substr(4, 2), 16) / 255\n    \n    // Apply gamma correction\n    const rs = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4)\n    const gs = g <= 0.03928 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4)\n    const bs = b <= 0.03928 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4)\n    \n    return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs\n  },\n  \n  /**\n   * Calculate contrast ratio between two colors\n   */\n  getContrastRatio(color1: string, color2: string): number {\n    const lum1 = this.getLuminance(color1)\n    const lum2 = this.getLuminance(color2)\n    \n    const brightest = Math.max(lum1, lum2)\n    const darkest = Math.min(lum1, lum2)\n    \n    return (brightest + 0.05) / (darkest + 0.05)\n  },\n  \n  /**\n   * Check if contrast ratio meets WCAG AA standards\n   */\n  meetsWCAGAA(color1: string, color2: string, isLargeText = false): boolean {\n    const ratio = this.getContrastRatio(color1, color2)\n    return isLargeText ? ratio >= 3 : ratio >= 4.5\n  },\n  \n  /**\n   * Check if contrast ratio meets WCAG AAA standards\n   */\n  meetsWCAGAAA(color1: string, color2: string, isLargeText = false): boolean {\n    const ratio = this.getContrastRatio(color1, color2)\n    return isLargeText ? ratio >= 4.5 : ratio >= 7\n  }\n}\n\n/**\n * Theme color pairs for testing\n */\nexport const themeColorPairs = {\n  base: {\n    primary: '#2563eb',\n    'primary-content': '#ffffff',\n    secondary: '#64748b',\n    'secondary-content': '#ffffff',\n    'base-100': '#ffffff',\n    'base-content': '#0f172a',\n    success: '#22c55e',\n    'success-content': '#ffffff',\n    warning: '#f59e0b',\n    'warning-content': '#ffffff',\n    error: '#ef4444',\n    'error-content': '#ffffff',\n    info: '#3b82f6',\n    'info-content': '#ffffff'\n  },\n  'cool-blue': {\n    primary: '#3b82f6',\n    'primary-content': '#ffffff',\n    secondary: '#6b7280',\n    'secondary-content': '#ffffff',\n    'base-100': '#f8fafc',\n    'base-content': '#1e293b',\n    success: '#10b981',\n    'success-content': '#ffffff',\n    warning: '#f59e0b',\n    'warning-content': '#ffffff',\n    error: '#ef4444',\n    'error-content': '#ffffff',\n    info: '#3b82f6',\n    'info-content': '#ffffff'\n  },\n  'midnight-purple': {\n    primary: '#a78bfa',\n    'primary-content': '#1f2937',\n    secondary: '#6b7280',\n    'secondary-content': '#f9fafb',\n    'base-100': '#1f2937',\n    'base-content': '#f9fafb',\n    success: '#34d399',\n    'success-content': '#1f2937',\n    warning: '#fbbf24',\n    'warning-content': '#1f2937',\n    error: '#f87171',\n    'error-content': '#1f2937',\n    info: '#60a5fa',\n    'info-content': '#1f2937'\n  }\n}\n\n/**\n * Test all theme color pairs for WCAG compliance\n */\nexport function testThemeColorContrast(themeName: keyof typeof themeColorPairs) {\n  const colors = themeColorPairs[themeName]\n  const results: Array<{\n    pair: string\n    ratio: number\n    meetsAA: boolean\n    meetsAAA: boolean\n  }> = []\n  \n  // Test semantic color pairs\n  const pairs = [\n    ['primary', 'primary-content'],\n    ['secondary', 'secondary-content'],\n    ['base-100', 'base-content'],\n    ['success', 'success-content'],\n    ['warning', 'warning-content'],\n    ['error', 'error-content'],\n    ['info', 'info-content']\n  ]\n  \n  pairs.forEach(([bg, fg]) => {\n    const bgColor = colors[bg as keyof typeof colors]\n    const fgColor = colors[fg as keyof typeof colors]\n    \n    if (bgColor && fgColor) {\n      const ratio = colorContrast.getContrastRatio(bgColor, fgColor)\n      results.push({\n        pair: `${bg}/${fg}`,\n        ratio,\n        meetsAA: colorContrast.meetsWCAGAA(bgColor, fgColor),\n        meetsAAA: colorContrast.meetsWCAGAAA(bgColor, fgColor)\n      })\n    }\n  })\n  \n  return results\n}\n\n/**\n * Accessibility test wrapper\n */\nexport interface AccessibilityTestOptions extends RenderOptions {\n  /** Skip axe accessibility testing */\n  skipAxe?: boolean\n  /** Custom axe configuration */\n  axeOptions?: any\n  /** Test color contrast */\n  testContrast?: boolean\n  /** Theme to test */\n  theme?: keyof typeof themeColorPairs\n}\n\n/**\n * Render component with accessibility testing\n */\nexport async function renderWithA11yTest(\n  ui: ReactElement,\n  options: AccessibilityTestOptions = {}\n) {\n  const {\n    skipAxe = false,\n    axeOptions = {},\n    testContrast = false,\n    theme = 'base',\n    ...renderOptions\n  } = options\n  \n  const result = render(ui, renderOptions)\n  \n  // Run axe accessibility tests\n  if (!skipAxe) {\n    const axeResults = await axe(result.container, {\n      rules: {\n        // Configure specific rules\n        'color-contrast': { enabled: true },\n        'keyboard-navigation': { enabled: true },\n        'focus-management': { enabled: true },\n        'aria-labels': { enabled: true },\n        'semantic-markup': { enabled: true },\n        ...axeOptions.rules\n      },\n      ...axeOptions\n    })\n    \n    expect(axeResults).toHaveNoViolations()\n  }\n  \n  // Test color contrast if requested\n  if (testContrast) {\n    const contrastResults = testThemeColorContrast(theme)\n    \n    contrastResults.forEach(({ pair, ratio, meetsAA }) => {\n      expect(meetsAA).toBe(true)\n      expect(ratio).toBeGreaterThanOrEqual(4.5)\n    })\n  }\n  \n  return result\n}\n\n/**\n * Keyboard navigation test utilities\n */\nexport const keyboardNavigation = {\n  /**\n   * Test tab navigation through elements\n   */\n  async testTabNavigation(elements: HTMLElement[]) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i]\n      \n      // Focus element\n      element.focus()\n      expect(element).toHaveFocus()\n      \n      // Check if element is keyboard accessible\n      expect(element).not.toHaveAttribute('tabindex', '-1')\n      \n      // Simulate tab key\n      if (i < elements.length - 1) {\n        // Move to next element\n        const nextElement = elements[i + 1]\n        nextElement.focus()\n        expect(nextElement).toHaveFocus()\n      }\n    }\n  },\n  \n  /**\n   * Test escape key handling\n   */\n  async testEscapeKey(element: HTMLElement, expectedBehavior: () => void) {\n    element.focus()\n    \n    // Simulate escape key\n    const escapeEvent = new KeyboardEvent('keydown', {\n      key: 'Escape',\n      code: 'Escape',\n      keyCode: 27\n    })\n    \n    element.dispatchEvent(escapeEvent)\n    expectedBehavior()\n  },\n  \n  /**\n   * Test enter/space key activation\n   */\n  async testKeyActivation(element: HTMLElement, expectedBehavior: () => void) {\n    element.focus()\n    \n    // Test Enter key\n    const enterEvent = new KeyboardEvent('keydown', {\n      key: 'Enter',\n      code: 'Enter',\n      keyCode: 13\n    })\n    \n    element.dispatchEvent(enterEvent)\n    expectedBehavior()\n    \n    // Test Space key\n    const spaceEvent = new KeyboardEvent('keydown', {\n      key: ' ',\n      code: 'Space',\n      keyCode: 32\n    })\n    \n    element.dispatchEvent(spaceEvent)\n    expectedBehavior()\n  }\n}\n\n/**\n * Screen reader test utilities\n */\nexport const screenReader = {\n  /**\n   * Test ARIA labels and descriptions\n   */\n  testAriaLabels(element: HTMLElement) {\n    // Check for accessible name\n    const accessibleName = element.getAttribute('aria-label') ||\n                          element.getAttribute('aria-labelledby') ||\n                          element.textContent\n    \n    expect(accessibleName).toBeTruthy()\n    expect(accessibleName?.trim()).not.toBe('')\n    \n    // Check for description if present\n    const ariaDescribedBy = element.getAttribute('aria-describedby')\n    if (ariaDescribedBy) {\n      const descriptionElement = document.getElementById(ariaDescribedBy)\n      expect(descriptionElement).toBeInTheDocument()\n      expect(descriptionElement?.textContent?.trim()).not.toBe('')\n    }\n  },\n  \n  /**\n   * Test semantic markup\n   */\n  testSemanticMarkup(element: HTMLElement, expectedRole?: string) {\n    if (expectedRole) {\n      expect(element).toHaveAttribute('role', expectedRole)\n    }\n    \n    // Check for proper heading hierarchy\n    if (element.tagName.match(/^H[1-6]$/)) {\n      const headingLevel = parseInt(element.tagName.charAt(1))\n      expect(headingLevel).toBeGreaterThanOrEqual(1)\n      expect(headingLevel).toBeLessThanOrEqual(6)\n    }\n  },\n  \n  /**\n   * Test live regions\n   */\n  testLiveRegions(element: HTMLElement) {\n    const ariaLive = element.getAttribute('aria-live')\n    if (ariaLive) {\n      expect(['polite', 'assertive', 'off']).toContain(ariaLive)\n    }\n    \n    const ariaAtomic = element.getAttribute('aria-atomic')\n    if (ariaAtomic) {\n      expect(['true', 'false']).toContain(ariaAtomic)\n    }\n  }\n}\n\n/**\n * Focus management test utilities\n */\nexport const focusManagement = {\n  /**\n   * Test focus trap in modal/dialog\n   */\n  async testFocusTrap(container: HTMLElement) {\n    const focusableElements = container.querySelectorAll(\n      'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\n    )\n    \n    expect(focusableElements.length).toBeGreaterThan(0)\n    \n    const firstElement = focusableElements[0] as HTMLElement\n    const lastElement = focusableElements[focusableElements.length - 1] as HTMLElement\n    \n    // Focus should start on first element\n    firstElement.focus()\n    expect(firstElement).toHaveFocus()\n    \n    // Tab from last element should go to first\n    lastElement.focus()\n    // Simulate tab key (this would need to be implemented in the component)\n    // expect(firstElement).toHaveFocus()\n  },\n  \n  /**\n   * Test focus restoration\n   */\n  testFocusRestoration(triggerElement: HTMLElement, modalElement: HTMLElement) {\n    // Focus trigger element\n    triggerElement.focus()\n    expect(triggerElement).toHaveFocus()\n    \n    // Open modal (focus moves to modal)\n    modalElement.focus()\n    expect(modalElement).toHaveFocus()\n    \n    // Close modal (focus should return to trigger)\n    // This would need to be implemented in the component\n    // expect(triggerElement).toHaveFocus()\n  }\n}\n\n/**\n * Complete accessibility test suite\n */\nexport async function runAccessibilityTestSuite(\n  ui: ReactElement,\n  options: AccessibilityTestOptions & {\n    testKeyboard?: boolean\n    testScreenReader?: boolean\n    testFocus?: boolean\n  } = {}\n) {\n  const {\n    testKeyboard = true,\n    testScreenReader = true,\n    testFocus = true,\n    ...renderOptions\n  } = options\n  \n  const result = await renderWithA11yTest(ui, renderOptions)\n  \n  // Test keyboard navigation\n  if (testKeyboard) {\n    const focusableElements = result.container.querySelectorAll(\n      'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\n    ) as NodeListOf<HTMLElement>\n    \n    if (focusableElements.length > 0) {\n      await keyboardNavigation.testTabNavigation(Array.from(focusableElements))\n    }\n  }\n  \n  // Test screen reader compatibility\n  if (testScreenReader) {\n    const interactiveElements = result.container.querySelectorAll(\n      'button, [role=\"button\"], input, select, textarea, a'\n    ) as NodeListOf<HTMLElement>\n    \n    interactiveElements.forEach(element => {\n      screenReader.testAriaLabels(element)\n      screenReader.testSemanticMarkup(element)\n    })\n  }\n  \n  return result\n}"