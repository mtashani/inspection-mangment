// Report Export and Management API Functions

import {
  FinalReport,
  ReportStatus,
  ExportFormat,
  ReportExportRequest,\n  ReportExportResult,\n  ReportStats,\n  ReportPrintLayout\n} from '../types/professional-reports'\n\nconst API_BASE = '/api/v1/report/management'\n\n// Utility function for API calls\nasync function apiCall<T>(\n  endpoint: string,\n  options: RequestInit = {}\n): Promise<T> {\n  const response = await fetch(`${API_BASE}${endpoint}`, {\n    headers: {\n      'Content-Type': 'application/json',\n      ...options.headers,\n    },\n    ...options,\n  })\n\n  if (!response.ok) {\n    const errorData = await response.json().catch(() => ({ message: 'Unknown error' }))\n    throw new Error(errorData.message || `HTTP ${response.status}: ${response.statusText}`)\n  }\n\n  return response.json()\n}\n\n// Report Export API\nexport const reportExportApi = {\n  // Export single report\n  async exportReport(\n    reportId: string,\n    format: ExportFormat,\n    options: {\n      includeImages?: boolean\n      includeAttachments?: boolean\n      customLayout?: ReportPrintLayout\n      watermark?: string\n      password?: string\n    } = {}\n  ): Promise<ReportExportResult> {\n    return apiCall('/export/single', {\n      method: 'POST',\n      body: JSON.stringify({\n        report_id: reportId,\n        format: format.toLowerCase(),\n        options\n      }),\n    })\n  },\n\n  // Export multiple reports\n  async exportMultipleReports(\n    reportIds: string[],\n    format: ExportFormat,\n    options: {\n      includeImages?: boolean\n      includeAttachments?: boolean\n      combineIntoSingle?: boolean\n      customLayout?: ReportPrintLayout\n      watermark?: string\n    } = {}\n  ): Promise<{\n    success: boolean\n    export_job_id: string\n    total_reports: number\n    estimated_completion: string\n    download_url?: string\n    message: string\n    started_at: string\n  }> {\n    return apiCall('/export/multiple', {\n      method: 'POST',\n      body: JSON.stringify({\n        report_ids: reportIds,\n        format: format.toLowerCase(),\n        options\n      }),\n    })\n  },\n\n  // Export reports by criteria\n  async exportReportsByCriteria(\n    criteria: {\n      inspectionIds?: string[]\n      templateIds?: string[]\n      status?: ReportStatus[]\n      dateRange?: {\n        from: string\n        to: string\n      }\n      createdBy?: string[]\n      equipmentTags?: string[]\n    },\n    format: ExportFormat,\n    options: {\n      includeImages?: boolean\n      includeAttachments?: boolean\n      combineIntoSingle?: boolean\n      customLayout?: ReportPrintLayout\n      maxReports?: number\n    } = {}\n  ): Promise<{\n    success: boolean\n    export_job_id: string\n    matching_reports: number\n    estimated_completion: string\n    message: string\n    started_at: string\n  }> {\n    return apiCall('/export/by-criteria', {\n      method: 'POST',\n      body: JSON.stringify({\n        criteria,\n        format: format.toLowerCase(),\n        options\n      }),\n    })\n  },\n\n  // Get export job status\n  async getExportJobStatus(jobId: string): Promise<{\n    success: boolean\n    job_id: string\n    status: 'pending' | 'processing' | 'completed' | 'failed' | 'cancelled'\n    progress: {\n      completed: number\n      total: number\n      percentage: number\n      current_task: string\n    }\n    result?: {\n      download_url: string\n      file_size: number\n      expires_at: string\n    }\n    error?: string\n    started_at: string\n    completed_at?: string\n    message: string\n  }> {\n    return apiCall(`/export/jobs/${jobId}/status`)\n  },\n\n  // Cancel export job\n  async cancelExportJob(jobId: string): Promise<{\n    success: boolean\n    job_id: string\n    message: string\n    cancelled_at: string\n  }> {\n    return apiCall(`/export/jobs/${jobId}/cancel`, {\n      method: 'POST',\n    })\n  },\n\n  // Get export history\n  async getExportHistory(params: {\n    userId?: string\n    fromDate?: string\n    toDate?: string\n    format?: ExportFormat\n    status?: string\n    limit?: number\n    offset?: number\n  } = {}): Promise<{\n    success: boolean\n    exports: Array<{\n      job_id: string\n      format: ExportFormat\n      status: string\n      report_count: number\n      file_size?: number\n      download_url?: string\n      expires_at?: string\n      created_by: string\n      started_at: string\n      completed_at?: string\n      error?: string\n    }>\n    total: number\n    has_more: boolean\n    message: string\n  }> {\n    const searchParams = new URLSearchParams()\n    \n    Object.entries(params).forEach(([key, value]) => {\n      if (value !== undefined) {\n        searchParams.append(key, value.toString())\n      }\n    })\n\n    return apiCall(`/export/history?${searchParams.toString()}`)\n  },\n\n  // Download exported file\n  async downloadExportedFile(jobId: string): Promise<Blob> {\n    const response = await fetch(`${API_BASE}/export/jobs/${jobId}/download`, {\n      method: 'GET',\n    })\n\n    if (!response.ok) {\n      throw new Error(`Failed to download file: ${response.statusText}`)\n    }\n\n    return response.blob()\n  },\n\n  // Get export templates (for custom layouts)\n  async getExportTemplates(format: ExportFormat): Promise<{\n    success: boolean\n    templates: Array<{\n      id: string\n      name: string\n      description: string\n      format: ExportFormat\n      layout: ReportPrintLayout\n      preview_url?: string\n      is_default: boolean\n      created_at: string\n    }>\n    message: string\n  }> {\n    return apiCall(`/export/templates?format=${format.toLowerCase()}`)\n  },\n\n  // Create custom export template (Admin only)\n  async createExportTemplate(\n    templateData: {\n      name: string\n      description: string\n      format: ExportFormat\n      layout: ReportPrintLayout\n      isDefault?: boolean\n    }\n  ): Promise<{\n    success: boolean\n    template_id: string\n    message: string\n    created_at: string\n  }> {\n    return apiCall('/export/templates', {\n      method: 'POST',\n      body: JSON.stringify(templateData),\n    })\n  }\n}\n\n// Report Management API\nexport const reportManagementApi = {\n  // Get reports with advanced filtering\n  async getReports(params: {\n    inspectionIds?: string[]\n    templateIds?: string[]\n    status?: ReportStatus[]\n    createdBy?: string[]\n    dateRange?: {\n      from: string\n      to: string\n    }\n    equipmentTags?: string[]\n    searchQuery?: string\n    sortBy?: 'created_at' | 'updated_at' | 'status' | 'template_name' | 'inspection_number'\n    sortOrder?: 'asc' | 'desc'\n    limit?: number\n    offset?: number\n  } = {}): Promise<{\n    success: boolean\n    reports: Array<{\n      id: string\n      inspection_id: string\n      inspection_number: string\n      equipment_tag: string\n      template_id: string\n      template_name: string\n      status: ReportStatus\n      created_by: string\n      created_by_name: string\n      created_at: string\n      updated_at: string\n      submitted_at?: string\n      approved_at?: string\n      approved_by?: string\n      serial_number: string\n      completion_percentage: number\n      field_count: number\n      completed_fields: number\n      has_attachments: boolean\n      file_size?: number\n    }>\n    total: number\n    has_more: boolean\n    filters_applied: Record<string, any>\n    message: string\n  }> {\n    const searchParams = new URLSearchParams()\n    \n    Object.entries(params).forEach(([key, value]) => {\n      if (value !== undefined) {\n        if (Array.isArray(value)) {\n          value.forEach(v => searchParams.append(key, v.toString()))\n        } else if (typeof value === 'object' && value !== null) {\n          Object.entries(value).forEach(([subKey, subValue]) => {\n            if (subValue !== undefined) {\n              searchParams.append(`${key}.${subKey}`, subValue.toString())\n            }\n          })\n        } else {\n          searchParams.append(key, value.toString())\n        }\n      }\n    })\n\n    return apiCall(`/reports?${searchParams.toString()}`)\n  },\n\n  // Get report details with full data\n  async getReportDetails(reportId: string): Promise<{\n    success: boolean\n    report: FinalReport & {\n      inspection: {\n        id: string\n        inspection_number: string\n        title: string\n        equipment_tag: string\n        equipment_description: string\n        start_date: string\n        end_date?: string\n        status: string\n      }\n      template: {\n        id: string\n        name: string\n        description: string\n        version: number\n        report_type: string\n      }\n      creator: {\n        id: string\n        name: string\n        email: string\n      }\n      approver?: {\n        id: string\n        name: string\n        email: string\n      }\n      attachments: Array<{\n        field_id: string\n        field_label: string\n        file_name: string\n        file_url: string\n        file_size: number\n        file_type: string\n        uploaded_at: string\n      }>\n      audit_trail: Array<{\n        timestamp: string\n        action: string\n        user_id: string\n        user_name: string\n        details: Record<string, any>\n      }>\n    }\n    message: string\n  }> {\n    return apiCall(`/reports/${reportId}/details`)\n  },\n\n  // Bulk update report status\n  async bulkUpdateStatus(\n    reportIds: string[],\n    newStatus: ReportStatus,\n    reason?: string\n  ): Promise<{\n    success: boolean\n    updated_reports: number\n    failed_updates: Array<{\n      report_id: string\n      error: string\n    }>\n    message: string\n    updated_at: string\n  }> {\n    return apiCall('/reports/bulk-update-status', {\n      method: 'PUT',\n      body: JSON.stringify({\n        report_ids: reportIds,\n        new_status: newStatus,\n        reason\n      }),\n    })\n  },\n\n  // Bulk delete reports\n  async bulkDeleteReports(\n    reportIds: string[],\n    reason?: string\n  ): Promise<{\n    success: boolean\n    deleted_reports: number\n    failed_deletions: Array<{\n      report_id: string\n      error: string\n    }>\n    message: string\n    deleted_at: string\n  }> {\n    return apiCall('/reports/bulk-delete', {\n      method: 'DELETE',\n      body: JSON.stringify({\n        report_ids: reportIds,\n        reason\n      }),\n    })\n  },\n\n  // Archive old reports\n  async archiveReports(\n    criteria: {\n      olderThan: string // ISO date\n      status?: ReportStatus[]\n      templateIds?: string[]\n      dryRun?: boolean\n    }\n  ): Promise<{\n    success: boolean\n    matching_reports: number\n    archived_reports?: number\n    archive_job_id?: string\n    dry_run_results?: Array<{\n      report_id: string\n      serial_number: string\n      created_at: string\n      status: ReportStatus\n    }>\n    message: string\n    started_at: string\n  }> {\n    return apiCall('/reports/archive', {\n      method: 'POST',\n      body: JSON.stringify(criteria),\n    })\n  },\n\n  // Get report statistics\n  async getReportStatistics(params: {\n    dateRange?: {\n      from: string\n      to: string\n    }\n    groupBy?: 'template' | 'status' | 'creator' | 'equipment' | 'month'\n    templateIds?: string[]\n    equipmentTags?: string[]\n  } = {}): Promise<{\n    success: boolean\n    statistics: {\n      total_reports: number\n      by_status: Record<ReportStatus, number>\n      by_template: Record<string, {\n        template_name: string\n        count: number\n        avg_completion_time: number\n      }>\n      by_creator: Record<string, {\n        creator_name: string\n        count: number\n        avg_completion_time: number\n      }>\n      completion_trends: Array<{\n        period: string\n        completed: number\n        submitted: number\n        approved: number\n      }>\n      average_completion_time: number\n      quality_metrics: {\n        approval_rate: number\n        rejection_rate: number\n        avg_revision_count: number\n      }\n    }\n    message: string\n  }> {\n    const searchParams = new URLSearchParams()\n    \n    Object.entries(params).forEach(([key, value]) => {\n      if (value !== undefined) {\n        if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n          Object.entries(value).forEach(([subKey, subValue]) => {\n            if (subValue !== undefined) {\n              searchParams.append(`${key}.${subKey}`, subValue.toString())\n            }\n          })\n        } else if (Array.isArray(value)) {\n          value.forEach(v => searchParams.append(key, v.toString()))\n        } else {\n          searchParams.append(key, value.toString())\n        }\n      }\n    })\n\n    return apiCall(`/reports/statistics?${searchParams.toString()}`)\n  },\n\n  // Get report audit trail\n  async getReportAuditTrail(reportId: string): Promise<{\n    success: boolean\n    audit_trail: Array<{\n      id: string\n      timestamp: string\n      action: 'created' | 'updated' | 'submitted' | 'approved' | 'rejected' | 'deleted' | 'exported'\n      user_id: string\n      user_name: string\n      user_role: string\n      details: {\n        field_changes?: Record<string, {\n          old_value: any\n          new_value: any\n        }>\n        status_change?: {\n          from: ReportStatus\n          to: ReportStatus\n          reason?: string\n        }\n        export_details?: {\n          format: ExportFormat\n          options: Record<string, any>\n        }\n        additional_notes?: string\n      }\n      ip_address?: string\n      user_agent?: string\n    }>\n    total_actions: number\n    message: string\n  }> {\n    return apiCall(`/reports/${reportId}/audit-trail`)\n  },\n\n  // Compare report versions\n  async compareReportVersions(\n    reportId: string,\n    version1: string,\n    version2: string\n  ): Promise<{\n    success: boolean\n    comparison: {\n      report_id: string\n      version1: {\n        timestamp: string\n        user_name: string\n        field_values: Record<string, any>\n      }\n      version2: {\n        timestamp: string\n        user_name: string\n        field_values: Record<string, any>\n      }\n      differences: Array<{\n        field_id: string\n        field_label: string\n        version1_value: any\n        version2_value: any\n        change_type: 'added' | 'removed' | 'modified'\n      }>\n      summary: {\n        total_changes: number\n        fields_added: number\n        fields_removed: number\n        fields_modified: number\n      }\n    }\n    message: string\n  }> {\n    return apiCall(`/reports/${reportId}/compare`, {\n      method: 'POST',\n      body: JSON.stringify({\n        version1,\n        version2\n      }),\n    })\n  }\n}\n\n// Report Search API\nexport const reportSearchApi = {\n  // Advanced search\n  async searchReports(\n    query: string,\n    filters: {\n      status?: ReportStatus[]\n      templateIds?: string[]\n      dateRange?: {\n        from: string\n        to: string\n      }\n      createdBy?: string[]\n      equipmentTags?: string[]\n      hasAttachments?: boolean\n      fieldValues?: Record<string, any>\n    } = {},\n    options: {\n      searchIn?: ('title' | 'description' | 'field_values' | 'serial_number')[]\n      fuzzySearch?: boolean\n      highlightMatches?: boolean\n      limit?: number\n      offset?: number\n    } = {}\n  ): Promise<{\n    success: boolean\n    results: Array<{\n      report_id: string\n      serial_number: string\n      template_name: string\n      inspection_number: string\n      equipment_tag: string\n      status: ReportStatus\n      created_at: string\n      relevance_score: number\n      highlights?: Record<string, string[]>\n      matched_fields?: Array<{\n        field_id: string\n        field_label: string\n        matched_value: string\n      }>\n    }>\n    total_results: number\n    search_time: number\n    suggestions?: string[]\n    message: string\n  }> {\n    return apiCall('/search', {\n      method: 'POST',\n      body: JSON.stringify({\n        query,\n        filters,\n        options\n      }),\n    })\n  },\n\n  // Get search suggestions\n  async getSearchSuggestions(\n    partialQuery: string,\n    context?: {\n      templateIds?: string[]\n      equipmentTags?: string[]\n      recentSearches?: boolean\n    }\n  ): Promise<{\n    success: boolean\n    suggestions: Array<{\n      text: string\n      type: 'equipment' | 'template' | 'field' | 'value' | 'recent'\n      category?: string\n      count?: number\n    }>\n    message: string\n  }> {\n    return apiCall('/search/suggestions', {\n      method: 'POST',\n      body: JSON.stringify({\n        partial_query: partialQuery,\n        context\n      }),\n    })\n  },\n\n  // Save search query\n  async saveSearchQuery(\n    name: string,\n    query: string,\n    filters: Record<string, any>\n  ): Promise<{\n    success: boolean\n    saved_search_id: string\n    message: string\n    saved_at: string\n  }> {\n    return apiCall('/search/save', {\n      method: 'POST',\n      body: JSON.stringify({\n        name,\n        query,\n        filters\n      }),\n    })\n  },\n\n  // Get saved searches\n  async getSavedSearches(): Promise<{\n    success: boolean\n    saved_searches: Array<{\n      id: string\n      name: string\n      query: string\n      filters: Record<string, any>\n      created_at: string\n      last_used: string\n      use_count: number\n    }>\n    message: string\n  }> {\n    return apiCall('/search/saved')\n  }\n}\n\n// Helper functions for report export and management\nexport const reportManagementHelpers = {\n  // Format file size\n  formatFileSize(bytes: number): string {\n    const sizes = ['Bytes', 'KB', 'MB', 'GB']\n    if (bytes === 0) return '0 Bytes'\n    const i = Math.floor(Math.log(bytes) / Math.log(1024))\n    return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i]\n  },\n\n  // Get export format icon\n  getExportFormatIcon(format: ExportFormat): string {\n    switch (format) {\n      case ExportFormat.PDF:\n        return '📄'\n      case ExportFormat.EXCEL:\n        return '📊'\n      case ExportFormat.JSON:\n        return '📋'\n      default:\n        return '📁'\n    }\n  },\n\n  // Get status badge color\n  getStatusBadgeColor(status: ReportStatus): string {\n    switch (status) {\n      case ReportStatus.DRAFT:\n        return 'gray'\n      case ReportStatus.SUBMITTED:\n        return 'blue'\n      case ReportStatus.UNDER_REVIEW:\n        return 'yellow'\n      case ReportStatus.APPROVED:\n        return 'green'\n      case ReportStatus.REJECTED:\n        return 'red'\n      default:\n        return 'gray'\n    }\n  },\n\n  // Calculate export progress\n  calculateExportProgress(completed: number, total: number): {\n    percentage: number\n    remaining: number\n    eta?: string\n  } {\n    const percentage = total > 0 ? Math.round((completed / total) * 100) : 0\n    const remaining = total - completed\n    \n    return {\n      percentage,\n      remaining,\n      // ETA calculation would be based on processing speed\n    }\n  },\n\n  // Generate export filename\n  generateExportFilename(\n    reportCount: number,\n    format: ExportFormat,\n    timestamp?: string\n  ): string {\n    const date = timestamp ? new Date(timestamp) : new Date()\n    const dateStr = date.toISOString().split('T')[0]\n    const timeStr = date.toTimeString().split(' ')[0].replace(/:/g, '-')\n    \n    const prefix = reportCount === 1 ? 'report' : `reports-${reportCount}`\n    const extension = format.toLowerCase()\n    \n    return `${prefix}-${dateStr}-${timeStr}.${extension}`\n  },\n\n  // Validate export options\n  validateExportOptions(\n    format: ExportFormat,\n    options: Record<string, any>\n  ): {\n    isValid: boolean\n    errors: string[]\n    warnings: string[]\n  } {\n    const errors: string[] = []\n    const warnings: string[] = []\n\n    // Format-specific validations\n    if (format === ExportFormat.PDF) {\n      if (options.customLayout) {\n        const layout = options.customLayout as ReportPrintLayout\n        if (layout.margins) {\n          const { top, right, bottom, left } = layout.margins\n          if (top + bottom >= 100 || left + right >= 100) {\n            errors.push('Margins are too large for page size')\n          }\n        }\n      }\n    }\n\n    if (format === ExportFormat.EXCEL) {\n      if (options.includeImages && options.combineIntoSingle) {\n        warnings.push('Including images in combined Excel export may result in large file size')\n      }\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings\n    }\n  },\n\n  // Parse search query\n  parseSearchQuery(query: string): {\n    terms: string[]\n    filters: Record<string, string[]>\n    operators: Array<{\n      field: string\n      operator: '=' | '!=' | '>' | '<' | 'contains' | 'starts_with'\n      value: string\n    }>\n  } {\n    const terms: string[] = []\n    const filters: Record<string, string[]> = {}\n    const operators: Array<{\n      field: string\n      operator: '=' | '!=' | '>' | '<' | 'contains' | 'starts_with'\n      value: string\n    }> = []\n\n    // Simple parsing - would be more sophisticated in real implementation\n    const words = query.split(/\\s+/)\n    \n    words.forEach(word => {\n      if (word.includes(':')) {\n        const [field, value] = word.split(':', 2)\n        if (!filters[field]) filters[field] = []\n        filters[field].push(value)\n      } else if (word.includes('=') || word.includes('!=') || word.includes('>') || word.includes('<')) {\n        // Parse operators\n        let operator: any = '='\n        let parts: string[] = []\n        \n        if (word.includes('!=')) {\n          operator = '!='\n          parts = word.split('!=')\n        } else if (word.includes('>=')) {\n          operator = '>'\n          parts = word.split('>=')\n        } else if (word.includes('<=')) {\n          operator = '<'\n          parts = word.split('<=')\n        } else if (word.includes('=')) {\n          operator = '='\n          parts = word.split('=')\n        }\n        \n        if (parts.length === 2) {\n          operators.push({\n            field: parts[0],\n            operator,\n            value: parts[1]\n          })\n        }\n      } else {\n        terms.push(word)\n      }\n    })\n\n    return {\n      terms,\n      filters,\n      operators\n    }\n  },\n\n  // Format search results\n  formatSearchResults(\n    results: any[],\n    query: string,\n    highlightMatches: boolean = true\n  ): any[] {\n    if (!highlightMatches) return results\n\n    const queryTerms = query.toLowerCase().split(/\\s+/)\n    \n    return results.map(result => {\n      const highlighted = { ...result }\n      \n      // Highlight matches in text fields\n      Object.keys(result).forEach(key => {\n        if (typeof result[key] === 'string') {\n          let text = result[key]\n          queryTerms.forEach(term => {\n            if (term.length > 2) {\n              const regex = new RegExp(`(${term})`, 'gi')\n              text = text.replace(regex, '<mark>$1</mark>')\n            }\n          })\n          highlighted[key] = text\n        }\n      })\n      \n      return highlighted\n    })\n  }\n}\n\n// Error handling utilities\nexport class ReportManagementApiError extends Error {\n  constructor(\n    message: string,\n    public statusCode?: number,\n    public errorCode?: string,\n    public exportJobId?: string\n  ) {\n    super(message)\n    this.name = 'ReportManagementApiError'\n  }\n}"