// Report Templates API Functions - Specialized for Template Management

import {
  Template,
  TemplateSection,
  TemplateSubSection,
  TemplateField,
  TemplateCreateRequest,
  TemplateUpdateRequest,
  FieldType,
  ValueSource,
  SectionType,
  AutoSource,
  TemplateBuilderState,
  CanvasGrid,
  FieldPosition
} from '../types/professional-reports'

const API_BASE = '/api/v1/report/templates'

// Utility function for API calls
async function apiCall<T>(
  endpoint: string,
  options: RequestInit = {}
): Promise<T> {
  const response = await fetch(`${API_BASE}${endpoint}`, {
    headers: {
      'Content-Type': 'application/json',
      ...options.headers,
    },
    ...options,
  })

  if (!response.ok) {
    const errorData = await response.json().catch(() => ({ message: 'Unknown error' }))
    throw new Error(errorData.message || `HTTP ${response.status}: ${response.statusText}`)
  }\n\n  return response.json()\n}\n\n// Template Structure API\nexport const templateStructureApi = {\n  // Get template with full structure\n  async getTemplateStructure(templateId: string): Promise<{\n    success: boolean\n    template: Template\n    fieldCount: number\n    sectionCount: number\n    autoFieldCount: number\n    message: string\n  }> {\n    return apiCall(`/${templateId}/structure`)\n  },\n\n  // Get template sections\n  async getTemplateSections(templateId: string): Promise<{\n    success: boolean\n    sections: TemplateSection[]\n    message: string\n  }> {\n    return apiCall(`/${templateId}/sections`)\n  },\n\n  // Create template section\n  async createSection(\n    templateId: string,\n    sectionData: {\n      title: string\n      sectionType: SectionType\n      order: number\n      isRequired: boolean\n    }\n  ): Promise<{\n    success: boolean\n    section_id: string\n    message: string\n    created_at: string\n  }> {\n    return apiCall(`/${templateId}/sections`, {\n      method: 'POST',\n      body: JSON.stringify(sectionData),\n    })\n  },\n\n  // Update template section\n  async updateSection(\n    templateId: string,\n    sectionId: string,\n    sectionData: Partial<TemplateSection>\n  ): Promise<{\n    success: boolean\n    section_id: string\n    message: string\n    updated_at: string\n  }> {\n    return apiCall(`/${templateId}/sections/${sectionId}`, {\n      method: 'PUT',\n      body: JSON.stringify(sectionData),\n    })\n  },\n\n  // Delete template section\n  async deleteSection(\n    templateId: string,\n    sectionId: string\n  ): Promise<{\n    success: boolean\n    message: string\n    deleted_at: string\n  }> {\n    return apiCall(`/${templateId}/sections/${sectionId}`, {\n      method: 'DELETE',\n    })\n  },\n\n  // Reorder sections\n  async reorderSections(\n    templateId: string,\n    sectionOrders: Array<{ sectionId: string; order: number }>\n  ): Promise<{\n    success: boolean\n    message: string\n    updated_at: string\n  }> {\n    return apiCall(`/${templateId}/sections/reorder`, {\n      method: 'PUT',\n      body: JSON.stringify({ section_orders: sectionOrders }),\n    })\n  }\n}\n\n// Template Subsections API\nexport const templateSubsectionsApi = {\n  // Get subsections for a section\n  async getSubsections(\n    templateId: string,\n    sectionId: string\n  ): Promise<{\n    success: boolean\n    subsections: TemplateSubSection[]\n    message: string\n  }> {\n    return apiCall(`/${templateId}/sections/${sectionId}/subsections`)\n  },\n\n  // Create subsection\n  async createSubsection(\n    templateId: string,\n    sectionId: string,\n    subsectionData: {\n      title: string\n      order: number\n      isRequired: boolean\n    }\n  ): Promise<{\n    success: boolean\n    subsection_id: string\n    message: string\n    created_at: string\n  }> {\n    return apiCall(`/${templateId}/sections/${sectionId}/subsections`, {\n      method: 'POST',\n      body: JSON.stringify(subsectionData),\n    })\n  },\n\n  // Update subsection\n  async updateSubsection(\n    templateId: string,\n    sectionId: string,\n    subsectionId: string,\n    subsectionData: Partial<TemplateSubSection>\n  ): Promise<{\n    success: boolean\n    subsection_id: string\n    message: string\n    updated_at: string\n  }> {\n    return apiCall(`/${templateId}/sections/${sectionId}/subsections/${subsectionId}`, {\n      method: 'PUT',\n      body: JSON.stringify(subsectionData),\n    })\n  },\n\n  // Delete subsection\n  async deleteSubsection(\n    templateId: string,\n    sectionId: string,\n    subsectionId: string\n  ): Promise<{\n    success: boolean\n    message: string\n    deleted_at: string\n  }> {\n    return apiCall(`/${templateId}/sections/${sectionId}/subsections/${subsectionId}`, {\n      method: 'DELETE',\n    })\n  },\n\n  // Reorder subsections\n  async reorderSubsections(\n    templateId: string,\n    sectionId: string,\n    subsectionOrders: Array<{ subsectionId: string; order: number }>\n  ): Promise<{\n    success: boolean\n    message: string\n    updated_at: string\n  }> {\n    return apiCall(`/${templateId}/sections/${sectionId}/subsections/reorder`, {\n      method: 'PUT',\n      body: JSON.stringify({ subsection_orders: subsectionOrders }),\n    })\n  }\n}\n\n// Template Fields API\nexport const templateFieldsApi = {\n  // Get fields for a subsection\n  async getFields(\n    templateId: string,\n    sectionId: string,\n    subsectionId: string\n  ): Promise<{\n    success: boolean\n    fields: TemplateField[]\n    message: string\n  }> {\n    return apiCall(`/${templateId}/sections/${sectionId}/subsections/${subsectionId}/fields`)\n  },\n\n  // Create field\n  async createField(\n    templateId: string,\n    sectionId: string,\n    subsectionId: string,\n    fieldData: {\n      label: string\n      fieldType: FieldType\n      valueSource: ValueSource\n      isRequired: boolean\n      options?: string[]\n      autoSourceKey?: string\n      validationRules?: any\n      placeholder?: string\n      helpText?: string\n      row: number\n      col: number\n      rowspan: number\n      colspan: number\n      order: number\n    }\n  ): Promise<{\n    success: boolean\n    field_id: string\n    message: string\n    created_at: string\n  }> {\n    return apiCall(`/${templateId}/sections/${sectionId}/subsections/${subsectionId}/fields`, {\n      method: 'POST',\n      body: JSON.stringify(fieldData),\n    })\n  },\n\n  // Update field\n  async updateField(\n    templateId: string,\n    sectionId: string,\n    subsectionId: string,\n    fieldId: string,\n    fieldData: Partial<TemplateField>\n  ): Promise<{\n    success: boolean\n    field_id: string\n    message: string\n    updated_at: string\n  }> {\n    return apiCall(`/${templateId}/sections/${sectionId}/subsections/${subsectionId}/fields/${fieldId}`, {\n      method: 'PUT',\n      body: JSON.stringify(fieldData),\n    })\n  },\n\n  // Delete field\n  async deleteField(\n    templateId: string,\n    sectionId: string,\n    subsectionId: string,\n    fieldId: string\n  ): Promise<{\n    success: boolean\n    message: string\n    deleted_at: string\n  }> {\n    return apiCall(`/${templateId}/sections/${sectionId}/subsections/${subsectionId}/fields/${fieldId}`, {\n      method: 'DELETE',\n    })\n  },\n\n  // Update field position (for canvas-based positioning)\n  async updateFieldPosition(\n    templateId: string,\n    fieldId: string,\n    position: FieldPosition\n  ): Promise<{\n    success: boolean\n    field_id: string\n    message: string\n    updated_at: string\n  }> {\n    return apiCall(`/${templateId}/fields/${fieldId}/position`, {\n      method: 'PUT',\n      body: JSON.stringify(position),\n    })\n  },\n\n  // Bulk update field positions\n  async bulkUpdateFieldPositions(\n    templateId: string,\n    fieldPositions: Array<{ fieldId: string; position: FieldPosition }>\n  ): Promise<{\n    success: boolean\n    updated_count: number\n    message: string\n    updated_at: string\n  }> {\n    return apiCall(`/${templateId}/fields/positions`, {\n      method: 'PUT',\n      body: JSON.stringify({ field_positions: fieldPositions }),\n    })\n  },\n\n  // Duplicate field\n  async duplicateField(\n    templateId: string,\n    fieldId: string,\n    newLabel?: string\n  ): Promise<{\n    success: boolean\n    original_field_id: string\n    duplicated_field_id: string\n    message: string\n    created_at: string\n  }> {\n    const params = new URLSearchParams()\n    if (newLabel) params.append('new_label', newLabel)\n    \n    return apiCall(`/${templateId}/fields/${fieldId}/duplicate?${params.toString()}`, {\n      method: 'POST',\n    })\n  }\n}\n\n// Template Validation API\nexport const templateValidationApi = {\n  // Validate entire template\n  async validateTemplate(templateId: string): Promise<{\n    success: boolean\n    validation_result: {\n      isValid: boolean\n      errors: Array<{\n        type: 'structure' | 'field' | 'logic' | 'canvas'\n        message: string\n        location?: string\n        severity: 'error' | 'warning' | 'info'\n      }>\n      warnings: Array<{\n        type: string\n        message: string\n        location?: string\n        suggestion?: string\n      }>\n      statistics: {\n        totalSections: number\n        totalSubsections: number\n        totalFields: number\n        requiredFields: number\n        autoFields: number\n        manualFields: number\n      }\n    }\n    message: string\n  }> {\n    return apiCall(`/${templateId}/validate`)\n  },\n\n  // Validate field configuration\n  async validateField(\n    templateId: string,\n    fieldId: string\n  ): Promise<{\n    success: boolean\n    field_validation: {\n      isValid: boolean\n      errors: string[]\n      warnings: string[]\n      suggestions: string[]\n    }\n    message: string\n  }> {\n    return apiCall(`/${templateId}/fields/${fieldId}/validate`)\n  },\n\n  // Validate canvas layout\n  async validateCanvasLayout(\n    templateId: string,\n    subsectionId: string\n  ): Promise<{\n    success: boolean\n    layout_validation: {\n      isValid: boolean\n      overlappingFields: Array<{\n        field1Id: string\n        field2Id: string\n        overlap: FieldPosition\n      }>\n      outOfBounds: Array<{\n        fieldId: string\n        position: FieldPosition\n      }>\n      gaps: Array<{\n        position: FieldPosition\n        size: number\n      }>\n      utilization: number\n    }\n    message: string\n  }> {\n    return apiCall(`/${templateId}/subsections/${subsectionId}/canvas/validate`)\n  },\n\n  // Check template completeness\n  async checkTemplateCompleteness(templateId: string): Promise<{\n    success: boolean\n    completeness: {\n      percentage: number\n      missingElements: Array<{\n        type: 'section' | 'subsection' | 'field'\n        description: string\n        priority: 'high' | 'medium' | 'low'\n      }>\n      recommendations: string[]\n    }\n    message: string\n  }> {\n    return apiCall(`/${templateId}/completeness`)\n  }\n}\n\n// Template Testing API\nexport const templateTestingApi = {\n  // Test template with sample data\n  async testTemplate(\n    templateId: string,\n    sampleData?: Record<string, any>\n  ): Promise<{\n    success: boolean\n    test_result: {\n      canRender: boolean\n      renderTime: number\n      autoFieldsPopulated: number\n      validationErrors: Record<string, string[]>\n      missingData: string[]\n      performanceMetrics: {\n        loadTime: number\n        renderTime: number\n        memoryUsage: number\n      }\n    }\n    message: string\n  }> {\n    return apiCall(`/${templateId}/test`, {\n      method: 'POST',\n      body: sampleData ? JSON.stringify({ sample_data: sampleData }) : undefined,\n    })\n  },\n\n  // Test auto-field population\n  async testAutoFields(\n    templateId: string,\n    inspectionId: string\n  ): Promise<{\n    success: boolean\n    auto_field_test: {\n      totalAutoFields: number\n      successfullyPopulated: number\n      failedFields: Array<{\n        fieldId: string\n        fieldLabel: string\n        sourceKey: string\n        error: string\n      }>\n      populatedValues: Record<string, any>\n    }\n    message: string\n  }> {\n    return apiCall(`/${templateId}/test-auto-fields`, {\n      method: 'POST',\n      body: JSON.stringify({ inspection_id: inspectionId }),\n    })\n  },\n\n  // Generate test report\n  async generateTestReport(\n    templateId: string,\n    testData?: Record<string, any>\n  ): Promise<{\n    success: boolean\n    test_report_url: string\n    format: 'pdf' | 'html'\n    message: string\n    generated_at: string\n  }> {\n    return apiCall(`/${templateId}/generate-test-report`, {\n      method: 'POST',\n      body: testData ? JSON.stringify({ test_data: testData }) : undefined,\n    })\n  }\n}\n\n// Template Canvas API (for drag-and-drop builder)\nexport const templateCanvasApi = {\n  // Get canvas configuration for subsection\n  async getCanvasConfig(\n    templateId: string,\n    subsectionId: string\n  ): Promise<{\n    success: boolean\n    canvas_config: {\n      grid: CanvasGrid\n      fields: TemplateField[]\n      settings: {\n        rows: number\n        cols: number\n        cellWidth: number\n        cellHeight: number\n        snapToGrid: boolean\n        showGrid: boolean\n      }\n    }\n    message: string\n  }> {\n    return apiCall(`/${templateId}/subsections/${subsectionId}/canvas`)\n  },\n\n  // Update canvas settings\n  async updateCanvasSettings(\n    templateId: string,\n    subsectionId: string,\n    settings: {\n      rows?: number\n      cols?: number\n      cellWidth?: number\n      cellHeight?: number\n      snapToGrid?: boolean\n      showGrid?: boolean\n    }\n  ): Promise<{\n    success: boolean\n    message: string\n    updated_at: string\n  }> {\n    return apiCall(`/${templateId}/subsections/${subsectionId}/canvas/settings`, {\n      method: 'PUT',\n      body: JSON.stringify(settings),\n    })\n  },\n\n  // Auto-arrange fields on canvas\n  async autoArrangeFields(\n    templateId: string,\n    subsectionId: string,\n    arrangement: 'grid' | 'flow' | 'compact'\n  ): Promise<{\n    success: boolean\n    arranged_fields: Array<{\n      fieldId: string\n      oldPosition: FieldPosition\n      newPosition: FieldPosition\n    }>\n    message: string\n    updated_at: string\n  }> {\n    return apiCall(`/${templateId}/subsections/${subsectionId}/canvas/auto-arrange`, {\n      method: 'POST',\n      body: JSON.stringify({ arrangement }),\n    })\n  },\n\n  // Check field collisions\n  async checkFieldCollisions(\n    templateId: string,\n    subsectionId: string\n  ): Promise<{\n    success: boolean\n    collisions: Array<{\n      field1Id: string\n      field2Id: string\n      overlap: FieldPosition\n      severity: 'minor' | 'major' | 'complete'\n    }>\n    message: string\n  }> {\n    return apiCall(`/${templateId}/subsections/${subsectionId}/canvas/collisions`)\n  }\n}\n\n// Helper functions for template management\nexport const templateHelpers = {\n  // Generate field ID\n  generateFieldId(): string {\n    return `field-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n  },\n\n  // Generate section ID\n  generateSectionId(): string {\n    return `section-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n  },\n\n  // Generate subsection ID\n  generateSubsectionId(): string {\n    return `subsection-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n  },\n\n  // Validate field type compatibility\n  isFieldTypeCompatible(fieldType: FieldType, valueSource: ValueSource): boolean {\n    // Auto fields can't be certain types\n    if (valueSource === ValueSource.AUTO) {\n      return ![\n        FieldType.IMAGE,\n        FieldType.FILE,\n        FieldType.SIGNATURE\n      ].includes(fieldType)\n    }\n    return true\n  },\n\n  // Get field type icon\n  getFieldTypeIcon(fieldType: FieldType): string {\n    switch (fieldType) {\n      case FieldType.TEXT:\n        return '📝'\n      case FieldType.TEXTAREA:\n        return '📄'\n      case FieldType.NUMBER:\n        return '🔢'\n      case FieldType.DATE:\n        return '📅'\n      case FieldType.CHECKBOX:\n        return '☑️'\n      case FieldType.SELECT:\n        return '📋'\n      case FieldType.MULTI_SELECT:\n        return '📋'\n      case FieldType.IMAGE:\n        return '🖼️'\n      case FieldType.FILE:\n        return '📎'\n      case FieldType.SIGNATURE:\n        return '✍️'\n      default:\n        return '❓'\n    }\n  },\n\n  // Get value source color\n  getValueSourceColor(valueSource: ValueSource): string {\n    switch (valueSource) {\n      case ValueSource.MANUAL:\n        return 'blue'\n      case ValueSource.AUTO:\n        return 'green'\n      case ValueSource.CALCULATED:\n        return 'purple'\n      default:\n        return 'gray'\n    }\n  },\n\n  // Calculate field grid position\n  calculateGridPosition(\n    fields: TemplateField[],\n    gridCols: number\n  ): FieldPosition {\n    // Find the next available position\n    const occupiedPositions = new Set<string>()\n    \n    fields.forEach(field => {\n      for (let r = field.row; r < field.row + field.rowspan; r++) {\n        for (let c = field.col; c < field.col + field.colspan; c++) {\n          occupiedPositions.add(`${r}-${c}`)\n        }\n      }\n    })\n\n    // Find first available position\n    let row = 1\n    let col = 1\n    \n    while (occupiedPositions.has(`${row}-${col}`)) {\n      col++\n      if (col > gridCols) {\n        col = 1\n        row++\n      }\n    }\n\n    return {\n      row,\n      col,\n      rowspan: 1,\n      colspan: 1\n    }\n  },\n\n  // Check if position is valid\n  isPositionValid(\n    position: FieldPosition,\n    gridRows: number,\n    gridCols: number,\n    existingFields: TemplateField[],\n    excludeFieldId?: string\n  ): boolean {\n    // Check bounds\n    if (\n      position.row < 1 ||\n      position.col < 1 ||\n      position.row + position.rowspan - 1 > gridRows ||\n      position.col + position.colspan - 1 > gridCols\n    ) {\n      return false\n    }\n\n    // Check for overlaps\n    const fieldsToCheck = existingFields.filter(f => f.id !== excludeFieldId)\n    \n    for (const field of fieldsToCheck) {\n      if (this.positionsOverlap(position, {\n        row: field.row,\n        col: field.col,\n        rowspan: field.rowspan,\n        colspan: field.colspan\n      })) {\n        return false\n      }\n    }\n\n    return true\n  },\n\n  // Check if two positions overlap\n  positionsOverlap(pos1: FieldPosition, pos2: FieldPosition): boolean {\n    const pos1EndRow = pos1.row + pos1.rowspan - 1\n    const pos1EndCol = pos1.col + pos1.colspan - 1\n    const pos2EndRow = pos2.row + pos2.rowspan - 1\n    const pos2EndCol = pos2.col + pos2.colspan - 1\n\n    return !(\n      pos1EndRow < pos2.row ||\n      pos2EndRow < pos1.row ||\n      pos1EndCol < pos2.col ||\n      pos2EndCol < pos1.col\n    )\n  },\n\n  // Generate template preview data\n  generatePreviewData(template: Template): Record<string, any> {\n    const previewData: Record<string, any> = {}\n\n    template.sections.forEach(section => {\n      section.subsections.forEach(subsection => {\n        subsection.fields.forEach(field => {\n          switch (field.fieldType) {\n            case FieldType.TEXT:\n              previewData[field.id] = 'Sample text'\n              break\n            case FieldType.TEXTAREA:\n              previewData[field.id] = 'Sample textarea content\\nMultiple lines'\n              break\n            case FieldType.NUMBER:\n              previewData[field.id] = 42\n              break\n            case FieldType.DATE:\n              previewData[field.id] = new Date().toISOString().split('T')[0]\n              break\n            case FieldType.CHECKBOX:\n              previewData[field.id] = true\n              break\n            case FieldType.SELECT:\n              previewData[field.id] = field.options?.[0] || 'Option 1'\n              break\n            case FieldType.MULTI_SELECT:\n              previewData[field.id] = field.options?.slice(0, 2) || ['Option 1', 'Option 2']\n              break\n            default:\n              previewData[field.id] = 'Sample value'\n          }\n        })\n      })\n    })\n\n    return previewData\n  },\n\n  // Calculate template complexity score\n  calculateComplexityScore(template: Template): {\n    score: number\n    level: 'simple' | 'moderate' | 'complex' | 'very_complex'\n    factors: {\n      sectionCount: number\n      fieldCount: number\n      autoFieldCount: number\n      validationRules: number\n      canvasComplexity: number\n    }\n  } {\n    let fieldCount = 0\n    let autoFieldCount = 0\n    let validationRules = 0\n    let canvasComplexity = 0\n\n    template.sections.forEach(section => {\n      section.subsections.forEach(subsection => {\n        subsection.fields.forEach(field => {\n          fieldCount++\n          if (field.valueSource === ValueSource.AUTO) autoFieldCount++\n          if (field.validationRules) validationRules++\n          \n          // Canvas complexity based on positioning\n          if (field.rowspan > 1 || field.colspan > 1) {\n            canvasComplexity += (field.rowspan * field.colspan) - 1\n          }\n        })\n      })\n    })\n\n    const factors = {\n      sectionCount: template.sections.length,\n      fieldCount,\n      autoFieldCount,\n      validationRules,\n      canvasComplexity\n    }\n\n    // Calculate weighted score\n    const score = (\n      factors.sectionCount * 2 +\n      factors.fieldCount * 1 +\n      factors.autoFieldCount * 1.5 +\n      factors.validationRules * 1.2 +\n      factors.canvasComplexity * 0.8\n    )\n\n    let level: 'simple' | 'moderate' | 'complex' | 'very_complex'\n    if (score < 20) level = 'simple'\n    else if (score < 50) level = 'moderate'\n    else if (score < 100) level = 'complex'\n    else level = 'very_complex'\n\n    return {\n      score,\n      level,\n      factors\n    }\n  }\n}\n\n// Error handling utilities\nexport class TemplateApiError extends Error {\n  constructor(\n    message: string,\n    public statusCode?: number,\n    public errorCode?: string,\n    public validationErrors?: Record<string, string[]>\n  ) {\n    super(message)\n    this.name = 'TemplateApiError'\n  }\n}"