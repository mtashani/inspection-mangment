// Maintenance Events CRUD API Functions - Enhanced Operations

import {\n  MaintenanceEvent,\n  MaintenanceSubEvent,\n  MaintenanceEventCreateRequest,\n  MaintenanceEventUpdateRequest,\n  MaintenanceSubEventCreateRequest,\n  MaintenanceSubEventUpdateRequest,\n  MaintenanceEventType,\n  MaintenanceEventStatus,\n  OverhaulSubType\n} from '../types/maintenance'\n\nconst API_BASE = '/api/v1/maintenance'\n\n// Utility function for API calls\nasync function apiCall<T>(\n  endpoint: string,\n  options: RequestInit = {}\n): Promise<T> {\n  const response = await fetch(`${API_BASE}${endpoint}`, {\n    headers: {\n      'Content-Type': 'application/json',\n      ...options.headers,\n    },\n    ...options,\n  })\n\n  if (!response.ok) {\n    const errorData = await response.json().catch(() => ({ message: 'Unknown error' }))\n    throw new Error(errorData.message || `HTTP ${response.status}: ${response.statusText}`)\n  }\n\n  return response.json()\n}\n\n// Enhanced Maintenance Events CRUD API\nexport const maintenanceCrudApi = {\n  // Create maintenance event with validation\n  async createMaintenanceEvent(\n    eventData: MaintenanceEventCreateRequest & {\n      equipmentId?: string\n      priority?: 'low' | 'medium' | 'high' | 'critical'\n      estimatedCost?: number\n      requiredSkills?: string[]\n      safetyRequirements?: string[]\n      permitRequired?: boolean\n      shutdownRequired?: boolean\n    }\n  ): Promise<{\n    success: boolean\n    event_id: string\n    event_number: string\n    validation_warnings: string[]\n    scheduling_conflicts: Array<{\n      conflicting_event_id: string\n      conflict_type: 'resource' | 'equipment' | 'personnel'\n      description: string\n    }>\n    message: string\n    created_at: string\n  }> {\n    return apiCall('/events/create', {\n      method: 'POST',\n      body: JSON.stringify(eventData),\n    })\n  },\n\n  // Get maintenance event with full details\n  async getMaintenanceEventDetails(eventId: string): Promise<{\n    success: boolean\n    event: MaintenanceEvent & {\n      equipment?: {\n        id: string\n        tag: string\n        description: string\n        location: string\n        type: string\n        unit: string\n      }\n      assignedPersonnel: Array<{\n        id: string\n        name: string\n        role: string\n        skills: string[]\n        availability: 'available' | 'busy' | 'unavailable'\n      }>\n      requiredResources: Array<{\n        id: string\n        name: string\n        type: 'tool' | 'material' | 'equipment'\n        quantity: number\n        unit: string\n        availability: 'available' | 'reserved' | 'unavailable'\n      }>\n      relatedDocuments: Array<{\n        id: string\n        name: string\n        type: 'procedure' | 'drawing' | 'manual' | 'permit'\n        url: string\n        version: string\n      }>\n      costBreakdown: {\n        labor: number\n        materials: number\n        equipment: number\n        overhead: number\n        total: number\n      }\n      riskAssessment: {\n        riskLevel: 'low' | 'medium' | 'high' | 'critical'\n        identifiedRisks: Array<{\n          description: string\n          probability: number\n          impact: number\n          mitigation: string\n        }>\n        safetyMeasures: string[]\n      }\n    }\n    message: string\n  }> {\n    return apiCall(`/events/${eventId}/details`)\n  },\n\n  // Update maintenance event with change tracking\n  async updateMaintenanceEvent(\n    eventId: string,\n    updateData: MaintenanceEventUpdateRequest & {\n      changeReason?: string\n      notifyStakeholders?: boolean\n    }\n  ): Promise<{\n    success: boolean\n    event_id: string\n    changes_made: Array<{\n      field: string\n      old_value: any\n      new_value: any\n      change_type: 'added' | 'modified' | 'removed'\n    }>\n    validation_warnings: string[]\n    scheduling_impacts: Array<{\n      impact_type: 'delay' | 'resource_conflict' | 'dependency'\n      description: string\n      affected_events: string[]\n    }>\n    notifications_sent: Array<{\n      recipient: string\n      method: 'email' | 'sms' | 'system'\n      status: 'sent' | 'failed'\n    }>\n    message: string\n    updated_at: string\n  }> {\n    return apiCall(`/events/${eventId}/update`, {\n      method: 'PUT',\n      body: JSON.stringify(updateData),\n    })\n  },\n\n  // Delete maintenance event with dependency check\n  async deleteMaintenanceEvent(\n    eventId: string,\n    options: {\n      reason: string\n      forceDelete?: boolean\n      transferSubEvents?: string // target event ID\n    }\n  ): Promise<{\n    success: boolean\n    event_id: string\n    dependencies_found: Array<{\n      type: 'sub_events' | 'linked_events' | 'resources' | 'documents'\n      count: number\n      description: string\n    }>\n    sub_events_handled: {\n      transferred: number\n      deleted: number\n      target_event_id?: string\n    }\n    message: string\n    deleted_at: string\n  }> {\n    return apiCall(`/events/${eventId}/delete`, {\n      method: 'DELETE',\n      body: JSON.stringify(options),\n    })\n  },\n\n  // Clone maintenance event\n  async cloneMaintenanceEvent(\n    eventId: string,\n    cloneOptions: {\n      newEventNumber?: string\n      newTitle?: string\n      newStartDate?: string\n      newEndDate?: string\n      includeSubEvents?: boolean\n      includeResources?: boolean\n      includePersonnel?: boolean\n    }\n  ): Promise<{\n    success: boolean\n    original_event_id: string\n    cloned_event_id: string\n    cloned_event_number: string\n    cloned_sub_events: number\n    adjustments_made: string[]\n    message: string\n    created_at: string\n  }> {\n    return apiCall(`/events/${eventId}/clone`, {\n      method: 'POST',\n      body: JSON.stringify(cloneOptions),\n    })\n  },\n\n  // Get maintenance event history\n  async getMaintenanceEventHistory(\n    eventId: string,\n    includeSubEvents: boolean = true\n  ): Promise<{\n    success: boolean\n    history: Array<{\n      timestamp: string\n      action: 'created' | 'updated' | 'status_changed' | 'sub_event_added' | 'sub_event_updated' | 'completed' | 'cancelled'\n      user_id: string\n      user_name: string\n      details: {\n        field_changes?: Record<string, {\n          old_value: any\n          new_value: any\n        }>\n        status_change?: {\n          from: MaintenanceEventStatus\n          to: MaintenanceEventStatus\n          reason?: string\n        }\n        sub_event_details?: {\n          sub_event_id: string\n          sub_event_title: string\n          action: string\n        }\n        additional_notes?: string\n      }\n      ip_address?: string\n    }>\n    total_actions: number\n    message: string\n  }> {\n    const params = new URLSearchParams({ include_sub_events: includeSubEvents.toString() })\n    return apiCall(`/events/${eventId}/history?${params.toString()}`)\n  }\n}\n\n// Enhanced Maintenance Sub-Events CRUD API\nexport const maintenanceSubEventsCrudApi = {\n  // Create sub-event with dependencies\n  async createSubEvent(\n    subEventData: MaintenanceSubEventCreateRequest & {\n      dependencies?: string[] // other sub-event IDs\n      estimatedDuration?: number // hours\n      requiredSkills?: string[]\n      criticalPath?: boolean\n    }\n  ): Promise<{\n    success: boolean\n    sub_event_id: string\n    sub_event_number: string\n    parent_event_updated: boolean\n    dependency_warnings: string[]\n    critical_path_impact: {\n      affects_completion: boolean\n      new_completion_date?: string\n      delay_impact: number // hours\n    }\n    message: string\n    created_at: string\n  }> {\n    return apiCall('/sub-events/create', {\n      method: 'POST',\n      body: JSON.stringify(subEventData),\n    })\n  },\n\n  // Get sub-event with dependencies\n  async getSubEventDetails(subEventId: string): Promise<{\n    success: boolean\n    sub_event: MaintenanceSubEvent & {\n      parentEvent: {\n        id: string\n        event_number: string\n        title: string\n        status: MaintenanceEventStatus\n      }\n      dependencies: Array<{\n        id: string\n        title: string\n        status: MaintenanceEventStatus\n        completion_percentage: number\n        dependency_type: 'finish_to_start' | 'start_to_start' | 'finish_to_finish'\n      }>\n      dependents: Array<{\n        id: string\n        title: string\n        status: MaintenanceEventStatus\n        blocked: boolean\n      }>\n      assignedPersonnel: Array<{\n        id: string\n        name: string\n        role: string\n        allocation_percentage: number\n      }>\n      actualCosts: {\n        labor: number\n        materials: number\n        equipment: number\n        total: number\n      }\n      timeTracking: {\n        planned_hours: number\n        actual_hours: number\n        remaining_hours: number\n        efficiency: number\n      }\n    }\n    message: string\n  }> {\n    return apiCall(`/sub-events/${subEventId}/details`)\n  },\n\n  // Update sub-event with impact analysis\n  async updateSubEvent(\n    subEventId: string,\n    updateData: MaintenanceSubEventUpdateRequest & {\n      updateReason?: string\n      recalculateSchedule?: boolean\n    }\n  ): Promise<{\n    success: boolean\n    sub_event_id: string\n    changes_made: Array<{\n      field: string\n      old_value: any\n      new_value: any\n    }>\n    parent_event_impact: {\n      completion_percentage_changed: boolean\n      new_completion_percentage: number\n      schedule_impact: {\n        delay_hours: number\n        new_end_date?: string\n        critical_path_affected: boolean\n      }\n    }\n    dependent_events_impact: Array<{\n      sub_event_id: string\n      impact_type: 'delayed' | 'blocked' | 'unblocked'\n      new_start_date?: string\n    }>\n    message: string\n    updated_at: string\n  }> {\n    return apiCall(`/sub-events/${subEventId}/update`, {\n      method: 'PUT',\n      body: JSON.stringify(updateData),\n    })\n  },\n\n  // Delete sub-event with dependency handling\n  async deleteSubEvent(\n    subEventId: string,\n    options: {\n      reason: string\n      handleDependencies: 'remove' | 'reassign' | 'merge'\n      targetSubEventId?: string // for reassign/merge\n    }\n  ): Promise<{\n    success: boolean\n    sub_event_id: string\n    dependencies_handled: {\n      removed_dependencies: number\n      reassigned_dependencies: number\n      merged_dependencies: number\n    }\n    parent_event_impact: {\n      completion_percentage_changed: boolean\n      new_completion_percentage: number\n    }\n    message: string\n    deleted_at: string\n  }> {\n    return apiCall(`/sub-events/${subEventId}/delete`, {\n      method: 'DELETE',\n      body: JSON.stringify(options),\n    })\n  },\n\n  // Update sub-event progress\n  async updateSubEventProgress(\n    subEventId: string,\n    progressData: {\n      completionPercentage: number\n      actualHours?: number\n      notes?: string\n      issues?: Array<{\n        description: string\n        severity: 'low' | 'medium' | 'high' | 'critical'\n        resolution?: string\n      }>\n      attachments?: Array<{\n        name: string\n        url: string\n        type: 'image' | 'document' | 'video'\n      }>\n    }\n  ): Promise<{\n    success: boolean\n    sub_event_id: string\n    old_completion: number\n    new_completion: number\n    parent_event_impact: {\n      old_completion: number\n      new_completion: number\n      status_changed: boolean\n      new_status?: MaintenanceEventStatus\n    }\n    milestone_achieved: boolean\n    next_milestone?: {\n      description: string\n      target_date: string\n      completion_required: number\n    }\n    message: string\n    updated_at: string\n  }> {\n    return apiCall(`/sub-events/${subEventId}/progress`, {\n      method: 'PUT',\n      body: JSON.stringify(progressData),\n    })\n  },\n\n  // Bulk update sub-events\n  async bulkUpdateSubEvents(\n    updates: Array<{\n      subEventId: string\n      updateData: Partial<MaintenanceSubEvent>\n    }>\n  ): Promise<{\n    success: boolean\n    total_updates: number\n    successful_updates: number\n    failed_updates: Array<{\n      sub_event_id: string\n      error: string\n    }>\n    parent_events_affected: Array<{\n      parent_event_id: string\n      completion_change: number\n      status_changed: boolean\n    }>\n    message: string\n    updated_at: string\n  }> {\n    return apiCall('/sub-events/bulk-update', {\n      method: 'PUT',\n      body: JSON.stringify({ updates }),\n    })\n  },\n\n  // Get sub-event dependencies graph\n  async getSubEventDependencies(parentEventId: string): Promise<{\n    success: boolean\n    dependency_graph: {\n      nodes: Array<{\n        id: string\n        title: string\n        status: MaintenanceEventStatus\n        completion_percentage: number\n        planned_start: string\n        planned_end: string\n        actual_start?: string\n        actual_end?: string\n        critical_path: boolean\n      }>\n      edges: Array<{\n        from: string\n        to: string\n        dependency_type: 'finish_to_start' | 'start_to_start' | 'finish_to_finish'\n        lag_hours: number\n      }>\n    }\n    critical_path: string[]\n    bottlenecks: Array<{\n      sub_event_id: string\n      reason: string\n      impact_hours: number\n    }>\n    message: string\n  }> {\n    return apiCall(`/sub-events/dependencies/${parentEventId}`)\n  }\n}\n\n// Maintenance Event Status Management API\nexport const maintenanceStatusApi = {\n  // Start maintenance event\n  async startMaintenanceEvent(\n    eventId: string,\n    startData: {\n      actualStartDate?: string\n      startingPersonnel: string[]\n      initialNotes?: string\n      safetyCheckCompleted: boolean\n      permitVerified?: boolean\n    }\n  ): Promise<{\n    success: boolean\n    event_id: string\n    old_status: MaintenanceEventStatus\n    new_status: MaintenanceEventStatus\n    actual_start_date: string\n    sub_events_started: number\n    notifications_sent: Array<{\n      recipient: string\n      type: 'start_notification'\n      status: 'sent' | 'failed'\n    }>\n    next_milestones: Array<{\n      description: string\n      target_date: string\n      responsible_person: string\n    }>\n    message: string\n    started_at: string\n  }> {\n    return apiCall(`/events/${eventId}/start`, {\n      method: 'POST',\n      body: JSON.stringify(startData),\n    })\n  },\n\n  // Complete maintenance event\n  async completeMaintenanceEvent(\n    eventId: string,\n    completionData: {\n      actualEndDate?: string\n      completionNotes: string\n      finalInspectionPassed: boolean\n      documentsCompleted: boolean\n      costSummary?: {\n        actualLabor: number\n        actualMaterials: number\n        actualEquipment: number\n      }\n      lessonsLearned?: string[]\n      recommendations?: string[]\n    }\n  ): Promise<{\n    success: boolean\n    event_id: string\n    old_status: MaintenanceEventStatus\n    new_status: MaintenanceEventStatus\n    actual_end_date: string\n    duration_analysis: {\n      planned_hours: number\n      actual_hours: number\n      variance_hours: number\n      efficiency_percentage: number\n    }\n    cost_analysis: {\n      planned_cost: number\n      actual_cost: number\n      variance_amount: number\n      variance_percentage: number\n    }\n    incomplete_sub_events: Array<{\n      id: string\n      title: string\n      completion_percentage: number\n      action_taken: 'auto_completed' | 'transferred' | 'cancelled'\n    }>\n    follow_up_actions: Array<{\n      description: string\n      assigned_to: string\n      due_date: string\n      priority: 'low' | 'medium' | 'high'\n    }>\n    message: string\n    completed_at: string\n  }> {\n    return apiCall(`/events/${eventId}/complete`, {\n      method: 'POST',\n      body: JSON.stringify(completionData),\n    })\n  },\n\n  // Pause/Hold maintenance event\n  async pauseMaintenanceEvent(\n    eventId: string,\n    pauseData: {\n      reason: string\n      expectedResumeDate?: string\n      impactAssessment: string\n      notifyStakeholders: boolean\n    }\n  ): Promise<{\n    success: boolean\n    event_id: string\n    old_status: MaintenanceEventStatus\n    new_status: MaintenanceEventStatus\n    pause_reason: string\n    expected_resume_date?: string\n    sub_events_paused: number\n    resource_impacts: Array<{\n      resource_type: 'personnel' | 'equipment' | 'material'\n      resource_id: string\n      impact: 'released' | 'held' | 'reassigned'\n    }>\n    schedule_impact: {\n      delay_hours: number\n      new_completion_date?: string\n      dependent_events_affected: number\n    }\n    message: string\n    paused_at: string\n  }> {\n    return apiCall(`/events/${eventId}/pause`, {\n      method: 'POST',\n      body: JSON.stringify(pauseData),\n    })\n  },\n\n  // Resume maintenance event\n  async resumeMaintenanceEvent(\n    eventId: string,\n    resumeData: {\n      actualResumeDate?: string\n      resumeNotes: string\n      resourcesConfirmed: boolean\n      scheduleAdjustments?: {\n        newPlannedEndDate?: string\n        adjustmentReason: string\n      }\n    }\n  ): Promise<{\n    success: boolean\n    event_id: string\n    old_status: MaintenanceEventStatus\n    new_status: MaintenanceEventStatus\n    actual_resume_date: string\n    pause_duration_hours: number\n    schedule_adjustments: {\n      end_date_changed: boolean\n      new_planned_end_date?: string\n      sub_events_rescheduled: number\n    }\n    resource_reallocations: Array<{\n      resource_type: string\n      resource_id: string\n      status: 'reallocated' | 'confirmed' | 'substituted'\n    }>\n    message: string\n    resumed_at: string\n  }> {\n    return apiCall(`/events/${eventId}/resume`, {\n      method: 'POST',\n      body: JSON.stringify(resumeData),\n    })\n  },\n\n  // Cancel maintenance event\n  async cancelMaintenanceEvent(\n    eventId: string,\n    cancellationData: {\n      reason: string\n      cancellationType: 'temporary' | 'permanent'\n      rescheduleDate?: string\n      costImpact: {\n        sunkCosts: number\n        cancellationCosts: number\n        recoveredCosts: number\n      }\n      resourceDisposition: {\n        releasePersonnel: boolean\n        returnMaterials: boolean\n        reallocateEquipment: boolean\n      }\n    }\n  ): Promise<{\n    success: boolean\n    event_id: string\n    old_status: MaintenanceEventStatus\n    new_status: MaintenanceEventStatus\n    cancellation_type: 'temporary' | 'permanent'\n    sub_events_cancelled: number\n    resources_released: {\n      personnel: number\n      equipment: number\n      materials: number\n    }\n    cost_impact: {\n      total_sunk_costs: number\n      cancellation_costs: number\n      recovered_costs: number\n      net_impact: number\n    }\n    rescheduled_event_id?: string\n    message: string\n    cancelled_at: string\n  }> {\n    return apiCall(`/events/${eventId}/cancel`, {\n      method: 'POST',\n      body: JSON.stringify(cancellationData),\n    })\n  }\n}\n\n// Helper functions for maintenance CRUD operations\nexport const maintenanceCrudHelpers = {\n  // Validate maintenance event data\n  validateMaintenanceEventData(\n    eventData: Partial<MaintenanceEvent>\n  ): {\n    isValid: boolean\n    errors: string[]\n    warnings: string[]\n  } {\n    const errors: string[] = []\n    const warnings: string[] = []\n\n    // Required fields\n    if (!eventData.eventNumber) {\n      errors.push('Event number is required')\n    }\n    if (!eventData.title) {\n      errors.push('Title is required')\n    }\n    if (!eventData.eventType) {\n      errors.push('Event type is required')\n    }\n    if (!eventData.plannedStartDate) {\n      errors.push('Planned start date is required')\n    }\n    if (!eventData.plannedEndDate) {\n      errors.push('Planned end date is required')\n    }\n\n    // Date validations\n    if (eventData.plannedStartDate && eventData.plannedEndDate) {\n      const startDate = new Date(eventData.plannedStartDate)\n      const endDate = new Date(eventData.plannedEndDate)\n      \n      if (startDate >= endDate) {\n        errors.push('Planned end date must be after start date')\n      }\n      \n      const now = new Date()\n      if (startDate < now) {\n        warnings.push('Planned start date is in the past')\n      }\n    }\n\n    // Status validations\n    if (eventData.status === MaintenanceEventStatus.COMPLETED) {\n      if (!eventData.actualEndDate) {\n        errors.push('Actual end date is required for completed events')\n      }\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings\n    }\n  },\n\n  // Calculate event duration\n  calculateEventDuration(\n    startDate: string,\n    endDate: string\n  ): {\n    hours: number\n    days: number\n    workingDays: number\n  } {\n    const start = new Date(startDate)\n    const end = new Date(endDate)\n    const diffTime = Math.abs(end.getTime() - start.getTime())\n    const hours = Math.ceil(diffTime / (1000 * 60 * 60))\n    const days = Math.ceil(diffTime / (1000 * 60 * 60 * 24))\n    \n    // Calculate working days (excluding weekends)\n    let workingDays = 0\n    const currentDate = new Date(start)\n    while (currentDate <= end) {\n      const dayOfWeek = currentDate.getDay()\n      if (dayOfWeek !== 0 && dayOfWeek !== 6) { // Not Sunday or Saturday\n        workingDays++\n      }\n      currentDate.setDate(currentDate.getDate() + 1)\n    }\n\n    return {\n      hours,\n      days,\n      workingDays\n    }\n  },\n\n  // Generate event number\n  generateEventNumber(\n    eventType: MaintenanceEventType,\n    year?: number\n  ): string {\n    const currentYear = year || new Date().getFullYear()\n    const typePrefix = {\n      [MaintenanceEventType.PREVENTIVE]: 'PM',\n      [MaintenanceEventType.CORRECTIVE]: 'CM',\n      [MaintenanceEventType.OVERHAUL]: 'OH',\n      [MaintenanceEventType.EMERGENCY]: 'EM',\n      [MaintenanceEventType.INSPECTION]: 'IN'\n    }[eventType]\n    \n    const timestamp = Date.now().toString().slice(-6)\n    return `${typePrefix}-${currentYear}-${timestamp}`\n  },\n\n  // Check scheduling conflicts\n  checkSchedulingConflicts(\n    newEvent: {\n      plannedStartDate: string\n      plannedEndDate: string\n      requiredResources?: string[]\n      assignedPersonnel?: string[]\n    },\n    existingEvents: MaintenanceEvent[]\n  ): Array<{\n    conflictingEventId: string\n    conflictType: 'resource' | 'personnel' | 'equipment'\n    description: string\n    severity: 'minor' | 'major' | 'critical'\n  }> {\n    const conflicts: Array<{\n      conflictingEventId: string\n      conflictType: 'resource' | 'personnel' | 'equipment'\n      description: string\n      severity: 'minor' | 'major' | 'critical'\n    }> = []\n\n    const newStart = new Date(newEvent.plannedStartDate)\n    const newEnd = new Date(newEvent.plannedEndDate)\n\n    existingEvents.forEach(existingEvent => {\n      if (existingEvent.status === MaintenanceEventStatus.CANCELLED) {\n        return // Skip cancelled events\n      }\n\n      const existingStart = new Date(existingEvent.plannedStartDate)\n      const existingEnd = new Date(existingEvent.plannedEndDate)\n\n      // Check for time overlap\n      const hasTimeOverlap = (\n        (newStart >= existingStart && newStart <= existingEnd) ||\n        (newEnd >= existingStart && newEnd <= existingEnd) ||\n        (newStart <= existingStart && newEnd >= existingEnd)\n      )\n\n      if (hasTimeOverlap) {\n        // Check for resource conflicts\n        // This would be more sophisticated in a real implementation\n        conflicts.push({\n          conflictingEventId: existingEvent.id,\n          conflictType: 'resource',\n          description: `Time overlap with ${existingEvent.title}`,\n          severity: 'major'\n        })\n      }\n    })\n\n    return conflicts\n  },\n\n  // Calculate completion percentage\n  calculateCompletionPercentage(\n    event: MaintenanceEvent\n  ): number {\n    if (!event.subEvents || event.subEvents.length === 0) {\n      return event.status === MaintenanceEventStatus.COMPLETED ? 100 : 0\n    }\n\n    const totalWeight = event.subEvents.length\n    const completedWeight = event.subEvents.reduce((sum, subEvent) => {\n      return sum + (subEvent.completionPercentage / 100)\n    }, 0)\n\n    return Math.round((completedWeight / totalWeight) * 100)\n  },\n\n  // Get next action for event\n  getNextAction(\n    event: MaintenanceEvent\n  ): {\n    action: string\n    description: string\n    priority: 'low' | 'medium' | 'high' | 'critical'\n    dueDate?: string\n    assignedTo?: string\n  } | null {\n    switch (event.status) {\n      case MaintenanceEventStatus.PLANNED:\n        const daysUntilStart = Math.ceil(\n          (new Date(event.plannedStartDate).getTime() - new Date().getTime()) / (1000 * 60 * 60 * 24)\n        )\n        \n        if (daysUntilStart <= 1) {\n          return {\n            action: 'start_event',\n            description: 'Event is scheduled to start soon',\n            priority: 'high',\n            dueDate: event.plannedStartDate\n          }\n        } else if (daysUntilStart <= 7) {\n          return {\n            action: 'prepare_resources',\n            description: 'Prepare resources and personnel for upcoming event',\n            priority: 'medium',\n            dueDate: event.plannedStartDate\n          }\n        }\n        break\n\n      case MaintenanceEventStatus.IN_PROGRESS:\n        const overdueTasks = event.subEvents?.filter(sub => {\n          const plannedEnd = new Date(sub.plannedEndDate)\n          return new Date() > plannedEnd && sub.status !== MaintenanceEventStatus.COMPLETED\n        }) || []\n\n        if (overdueTasks.length > 0) {\n          return {\n            action: 'address_overdue_tasks',\n            description: `${overdueTasks.length} sub-events are overdue`,\n            priority: 'critical'\n          }\n        }\n        break\n\n      case MaintenanceEventStatus.ON_HOLD:\n        return {\n          action: 'review_hold_status',\n          description: 'Review and determine if event can be resumed',\n          priority: 'medium'\n        }\n    }\n\n    return null\n  }\n}\n\n// Error handling utilities\nexport class MaintenanceCrudApiError extends Error {\n  constructor(\n    message: string,\n    public statusCode?: number,\n    public errorCode?: string,\n    public validationErrors?: string[]\n  ) {\n    super(message)\n    this.name = 'MaintenanceCrudApiError'\n  }\n}"